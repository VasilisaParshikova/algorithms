# На вершине лесенки, содержащей N ступенек, находится мячик, который начинает прыгать по ним вниз, к основанию.
# Мячик может прыгнуть на следующую ступеньку, на ступеньку через одну или через 2.
# (То есть, если мячик лежит на 8-ой ступеньке, то он может переместиться на 5-ую, 6-ую или 7-ую.)
# Определить число всевозможных «маршрутов» мячика с вершины на землю.


# Идея решения
# На первую ступеньку можно попасть только одним образом — сделав прыжок с длиной равной единице.
# На вторую ступеньку можно попасть сделав прыжок длиной 2, или с первой ступеньки — всего 2 варианта.
# На третью ступеньку можно попасть сделав прыжок длиной три, с первой или со втрой ступенек.
# Т.е. всего 4 варианта (0->3; 0->1->3; 0->2->3; 0->1->2->3). Теперь рассмотрим четвёртую ступеньку.
# На неё можно попасть с первой ступеньки — по одному маршруту на каждый маршрут до неё, со второй или
# с третьей — аналогично. Иными словами, количество путей до 4-й ступеньки есть сумма маршрутов
# до 1-й, 2-й и 3-й ступенек. Математически выражаясь, F(N) = F(N-1)+F(N-2)+F(N-3).
# Первые три ступеньки будем считать начальными состояниями.

import time

# рекурсивное решение

def recursion_f(n: int):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        return recursion_f(n-1) + recursion_f(n-2) + recursion_f(n-3)


start_time = time.time()
res = recursion_f(20)
elapsed_time = time.time() - start_time
print(f'Рекурсия. Ответ:{res}. Время в мс:{elapsed_time * 1000:.4f}')

# Через массив значений

# Так как каждое следующее значение зависит только от трёх предыдущих, ни одно значение под индексом меньше i-3
# нам бы не пригодилось. В приведённом выше коде мы записываем новое значение на место самого старого,
# не нужного больше. Цикличность остатка от деления на 3 помогает нам избежать кучи условных операторов.

def linear_f(n):
    result = [1, 2, 4]
    for i in range(3, n):
        result[i % 3] = result[0] + result[1] + result[2]

    return result[(n-1) % 3]

start_time = time.time()
res = linear_f(3000)
elapsed_time = time.time() - start_time
print(f'Линейная функция. Ответ:{res}. Время в мс:{elapsed_time * 1000:.4f}')