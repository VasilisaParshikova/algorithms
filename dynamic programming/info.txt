Динамическое программирование — метод решения задачи путём её разбиения на несколько одинаковых подзадач,
рекуррентно связанных между собой. Самым простым примером будут числа Фибоначчи — чтобы вычислить некоторое
число в этой последовательности, нам нужно сперва вычислить третье число, сложив первые два, затем четвёртое
таким же образом на основе второго и третьего, и так далее (да, мы слышали про замкнутую формулу).

Решение задачи динамическим программированием должно содержать следующее:

1. Зависимость элементов динамики друг от друга. Такая зависимость может быть прямо дана в условии
(так часто бывает, если это задача на числовые последовательности). В противном случае вы можете
попытаться узнать какой-то известный числовой ряд (вроде тех же чисел Фибоначчи), вычислив первые
несколько значений вручную. Если вам совсем не повезло — придётся думать ?
2. Значение начальных состояний. В результате долгого разбиения на подзадачи вам необходимо свести функцию либо
к уже известным значениям (как в случае с Фибоначчи — заранее определены первые два члена), либо к задаче,
решаемой элементарно.

Варианты подходов:
Рекурсивно
Рекурсивно с кэшированием значений (Идея мемоизации очень проста — единожды вычисляя значение, мы заносим его в
                                    какую-то структуру данных. Перед каждым вычислением мы проверяем, есть ли
                                    вычисляемое значение в этой структуре, и если есть, используем его.)
Последовательное вычисление (Суть метода в следующем: мы создаём массив на N элементов и последовательно заполняем его
                             значениями. Вы, наверное, уже догадались, что таким образом мы можем вычислять в том числе
                             те значения, которые для ответа не нужны. В значительной части задач на динамику этот факт
                             можно опустить, так как для ответа часто бывают нужны как раз все значения. Например, при
                             поиске наименьшего пути мы не можем не вычислять путь до какой-то точки, нам нужно
                             пересмотреть все варианты.)
Создание стека индексов (Сейчас нам предстоит, по сути, написать свою собственную рекурсию. Идея состоит в следующем —
                        сначала мы проходим «вниз» от N до начальных состояний, запоминая аргументы, функцию от которых
                        нам нужно будет вычислять. Затем возвращаемся «вверх», последовательно вычисляя значения от этих
                        аргументов, в том порядке, который мы записали.)